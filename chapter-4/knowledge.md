# 数组、切片和映射

## 主要内容
* 数组的内部实现和基础功能
* 使用切片管理数组集合
* 使用映射管理键值对

## 1数组
### 1.1声明和初始化


```
# 声明一个包含5个元素的整形数组
var array [5]int
```
一旦声明，数组的类型和长度就不可以再改变，在声明时，go 语言会以各种类型的0值对数组元素进行赋值。
也可以使用下面方法直接赋值：
```
# 用具体值初始化每个元素
array := [5]int{1,2,3,4,5}

# 容量由初始化的数量决定
array := [...]int{1,2,3,4,5}

# 初始化具体索引的值
array := [5]int{1:10, 2:20}
```


### 1.2赋值
在 go 中，数组是个值，变量名代表整个数组。可以将数组直接赋值给同类型的数组。

**同类型是指：数组元素类型和元素个数都相同的**

### 1.3多维数组

声明二维数组：
```
var array [4][2]int

# 声明并且初始化二维数组
array := [4][2]int{{1,2}, {3,4}, {5,6}, {7,8}}

# 声明并初始化特定元素的值
array := [4][2]int{1:{1,2}, 2:{3,4}}
array := [4][2]int{1:{0:1}, 2:{0:3}}
```

### 1.4函数间数组的传递

在函数间传递函数的时候，总是以值的方式传递的，如果这个变量是一个数组，那么不管有多长，总是会将要传递的数组进行复制，可能导致开销过大。
因此，可以传递指向数组的指针。这样只传递地址，而不是整个数组变量。

```
# 值传递
array1 := [1e6]int
foo(array1)
func foo(array []int) {...}

# 地址传递
array2 := [1e6]int
foo(&array2)
func foo(array *[]int) {...}
```
需要注意，因为传递的是指针，在改变指针指向的值的时候，需要注意。

## 2切片

### 2.1内部实现
切片是对数组的抽象，并提供相关方法。有3个字段，分别是 *数组的地址指针，数组的长度，数组的容量*。

### 2.2切片的创建和初始化
[切片和数组，长度和容量](https://linux.cn/article-8564-1.html)

make 创建切片
```
# make长度和容量都是5的字符串切片
slice := make([]string, 5)

# make长度为3，容量为5的整形切片
slice := make([]int, 3, 5)

# 不允许创建长度大于容量的切片
slice := make([]int, 5, 3)
compiler Error:
len larger then cap in make ([]int)
```
使用切片字面量
```
# 创建切片时，可以指定长度和容量，方法是初始化时给出的长度和索引
# 创建长度和容量都是100的字符串切片
slice := []string{99:""}

# 在[]指定值则为数组，不指定值则为切片
# 数组
array := [3]int{1,2,3}
# 切片
slice := []int{1,2,3}
```


nil 和空切片
在声明切片时不做任何初始化，就会创建一个nil切片
```
var slice []int
```
空切片在底层包括0个元素，也没有分配任何储存空间
```
# 使用 make 创建空切片
slice := make([]int, 0)

# 使用切片字面量创建空切片
slice := []int{}
```

### 2.3使用切片
切片之所以被称为切片，是因为创建一个切片就是把底层数组切出一部分。
```
# 创建一个新切片，长度和容量都是5
slice := []int{1,2,3,4,5}

# 创建新切片，长度为2，容量为4
newSlice := slice[1:3]
```

计算长度和容量
```
# 对于底层数组容量为 k 的切片 slice[i:j] 来说
长度 ： j-i
容量 ： k-i
```

#### 2.3.1 切片赋值


