# 数组、切片和映射

## 主要内容
* 数组的内部实现和基础功能
* 使用切片管理数组集合
* 使用映射管理键值对

## 1数组
### 1.1声明和初始化


```
# 声明一个包含5个元素的整形数组
var array [5]int
```
一旦声明，数组的类型和长度就不可以再改变，在声明时，go 语言会以各种类型的0值对数组元素进行赋值。
也可以使用下面方法直接赋值：
```
# 用具体值初始化每个元素
array := [5]int{1,2,3,4,5}

# 容量由初始化的数量决定
array := [...]int{1,2,3,4,5}

# 初始化具体索引的值
array := [5]int{1:10, 2:20}
```


### 1.2赋值
在 go 中，数组是个值，变量名代表整个数组。可以将数组直接赋值给同类型的数组。

**同类型是指：数组元素类型和元素个数都相同的**

### 1.3多维数组

声明二维数组：
```
var array [4][2]int

# 声明并且初始化二维数组
array := [4][2]int{{1,2}, {3,4}, {5,6}, {7,8}}

# 声明并初始化特定元素的值
array := [4][2]int{1:{1,2}, 2:{3,4}}
array := [4][2]int{1:{0:1}, 2:{0:3}}
```

### 1.4函数间数组的传递

在函数间传递函数的时候，总是以值的方式传递的，如果这个变量是一个数组，那么不管有多长，总是会将要传递的数组进行复制，可能导致开销过大。
因此，可以传递指向数组的指针。这样只传递地址，而不是整个数组变量。

```
# 值传递
array1 := [1e6]int
foo(array1)
func foo(array []int) {...}

# 地址传递
array2 := [1e6]int
foo(&array2)
func foo(array *[]int) {...}
```
需要注意，因为传递的是指针，在改变指针指向的值的时候，需要注意。

## 2切片

### 2.1内部实现
切片是对数组的抽象，并提供相关方法。有3个字段，分别是 *数组的地址指针，数组的长度，数组的容量*。

### 2.2切片的创建和初始化
[切片和数组，长度和容量](https://linux.cn/article-8564-1.html)

make 创建切片
```
# make长度和容量都是5的字符串切片
slice := make([]string, 5)

# make长度为3，容量为5的整形切片
slice := make([]int, 3, 5)

# 不允许创建长度大于容量的切片
slice := make([]int, 5, 3)
compiler Error:
len larger then cap in make ([]int)
```
使用切片字面量
```
# 创建切片时，可以指定长度和容量，方法是初始化时给出的长度和索引
# 创建长度和容量都是100的字符串切片
slice := []string{99:""}

# 在[]指定值则为数组，不指定值则为切片
# 数组
array := [3]int{1,2,3}
# 切片
slice := []int{1,2,3}
```


nil 和空切片
在声明切片时不做任何初始化，就会创建一个nil切片
```
var slice []int
```
空切片在底层包括0个元素，也没有分配任何储存空间
```
# 使用 make 创建空切片
slice := make([]int, 0)

# 使用切片字面量创建空切片
slice := []int{}
```

### 2.3使用切片
切片之所以被称为切片，是因为创建一个切片就是把底层数组切出一部分。
```
# 创建一个新切片，长度和容量都是5
slice := []int{1,2,3,4,5}

# 创建新切片，长度为2，容量为4
newSlice := slice[1:3]
```

计算长度和容量
```
# 对于底层数组容量为 k 的切片 slice[i:j] 来说
长度 ： j-i
容量 ： k-i
```

#### 2.3.1 切片赋值
从底层数组切出来的一部分成为切片。此时，切片和原数组共享部分内存。如果修改其中一个的值，另一个也能感知到。
```
# 修改切片可能导致的结果
slice := []int{1,2,3,4,5}
newSlice := slice[1:3]

# 修改 newSlice 索引值为1（第二个元素）的值
# 同时也会修改 slice 索引值为2（第三个元素）的值
newSlice[1] = 6
```
切片只允许访问其长度之内的值，访问超出长度的元素会抛出异常。
切片的容量只用于切片增长时，利用 go 的 append 函数，可以将切片的容量合并到长度。

#### 2.3.4 切片增长
切片相对于数组的好处就是，可以按需增加切片的容量。
使用 apend 时，需要一个要被操作的切片和要追加的值。调用之后，会返回一个被修改的切片。
```
# 创建新切片
# 长度和容量都是5
slice := []int{1,2,3,4,5}

# 通过索引创建新的切片
# 长度为2，容量为4
newSlice := slice[1:3]

# 向新切片追加元素
newSlice = append(newSlice, 6)

# 此时的切片以及底层数组
slice:[1,2,3,6,5]
newSlice:[2,3,6]
```

如果切片还有容量，append 将新元素追加到切片的剩余容量。如果切片的底层数组没有足够的可用的容量，append 会创建一个新的底层数组，把切片引用的数组复制到新数组，然后再追加新的值。
```
slice := []int{1,2,3,4}
newSlice := append(slice, 5)
```
此时，append 会创建新的底层数组，并且处理数组的容量。
在切片容量小于1000时，容量会加倍增加，每次增加为原来的2倍。当长度大于1000时，增长速度改为1.25倍。

