## 协程(goroutine)
协程有时也被称为绿色线程。
绿色线程是由程序运行时(runtime)维护的线程。一个绿色线程的开销常常会比系统线程小得多。只要内存充足，一个程序可以轻松支持上万个并发协程。

每个 Go 程序启动的时候只有一个对用户可见的协程，称之为主协程。一个协程可以开启更多其他新的协程。
只需在函数调用之前使用呢 go 关键字，就可以让此函数运行在一个新的协程之内。当此函数退出后，这个新的协程也就随之结束了。

当一个程序的主协程退出时，此程序也就退出了，即使还有一些其他的协程在运行。

## 并发同步(concurrency synchronization)
如何确保主协程在所有协程都结束之后再退出呢？必须使用某种并发同步技术来达到此目的。
Go 支持几种并发同步技术，最常用的是数据通道(channel)技术。
可以使用 sync 标准库中的 WaitGroup 来同步上面这个程序中的主协程和两个新建的协程。

WaitGroup 类型有 3 个方法：Add、Done、Wait、
* Add 方法来注册新的需要完成的任务数目
* Done 用来通知某个任务已经完成了
* Wait 方法调用将阻塞(等待)所有任务都完成之后才继续执行后面的语句

**一个处于阻塞状态的协程不会自发的结束阻塞状态，它必须被另外一个协程通过某种并发同步方法来被动地结束阻塞状态。**
如果一个运行中的程序当前所有的协程都处于阻塞状态，则这些协程将永远处于阻塞状态，程序将被视为死锁了。

## 延迟调用函数
在 Go 中，一个函数可以跟在一个 *defer* 关键字后面，形成一个延迟函数调用。
当一个函数被延迟调用之后，他不会被立即执行，而是被推入由当前协程维护的一个延迟调用堆栈。当有一个函数执行结束进入退出阶段时，则在此调用中被推入的延迟调用将按照被推入堆栈的顺序**逆序**执行。当所有这些延迟调用执行完毕之后，此函数调用也真正退出了。

```
package main 
import "fmt"

func main () {
    defer fmt.Println("third")
    defer fmt.Println("second")
    fmt.Println("first")
}

# 输出结果
tirst
second
third
```

事实上，一个协程调用会维护两个堆栈。
* 一个是正常的函数调用堆栈
* 另一个是延迟调用的堆栈

## 恐慌(panic)和恢复(recover)
Go 不支持异常抛出和捕获，而是希望显示的使用返回值返回错误。
不过，Go 支持一套类似的机制，称为恐慌/恢复机制。
